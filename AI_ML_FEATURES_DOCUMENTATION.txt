================================================================================
AI & ML FEATURES DOCUMENTATION - JANASPANDANA APPLICATION
================================================================================

Date: 2024
Version: 1.0

This document describes all AI and Machine Learning features incorporated into
the Janaspandana civic issue reporting application.

================================================================================
TABLE OF CONTENTS
================================================================================

1. Overview
2. AI/ML Features Implemented
3. Technical Implementation Details
4. How Each Feature Works
5. API Endpoints
6. Frontend Integration
7. Future Enhancements

================================================================================
1. OVERVIEW
================================================================================

The Janaspandana application now includes comprehensive AI and ML capabilities
to enhance civic issue reporting, prioritization, and management. These
features help automate tasks, improve decision-making, and provide valuable
insights to administrators and workers.

================================================================================
2. AI/ML FEATURES IMPLEMENTED
================================================================================

2.1 PRIORITY SCORING ALGORITHM
   - Automatically calculates priority scores (0-100) for each report
   - Helps workers and admins identify which issues need immediate attention

2.2 DUPLICATE DETECTION
   - Identifies potential duplicate reports using location and text similarity
   - Prevents redundant work and helps consolidate similar issues

2.3 SENTIMENT ANALYSIS
   - Analyzes comments and descriptions for positive, negative, or neutral sentiment
   - Helps understand public perception and urgency

2.4 AUTO-TAGGING
   - Automatically generates relevant tags based on report content
   - Improves searchability and categorization

2.5 IMAGE CLASSIFICATION
   - Classifies report type from images and text descriptions
   - Validates user-selected report types

2.6 PREDICTIVE ANALYTICS
   - Identifies high-risk areas that may need attention
   - Clusters reports by location to find problem hotspots

================================================================================
3. TECHNICAL IMPLEMENTATION DETAILS
================================================================================

3.1 BACKEND ARCHITECTURE

Location: janaspandana-api/services/aiService.js

The AI service is a Node.js module that provides various ML functions:

- Uses the 'natural' library for NLP operations (text similarity, tokenization)
- Implements rule-based and statistical ML algorithms
- Processes data in real-time when reports are submitted
- Stores AI-generated metadata in the database

3.2 DATABASE SCHEMA UPDATES

The Report model has been extended with AI fields:

- priority_score: Number (0-100)
- ai_tags: Array of strings
- is_duplicate: Boolean
- duplicate_of: Reference to another report
- ai_classification: Object with predicted_type and confidence
- sentiment_analysis: Object with sentiment and score

3.3 DEPENDENCIES

Backend:
- natural: ^0.12.0 (Natural Language Processing library)
  - Provides: Jaro-Winkler distance, tokenization, text analysis

Frontend:
- No additional ML libraries (uses backend API)

================================================================================
4. HOW EACH FEATURE WORKS
================================================================================

4.1 PRIORITY SCORING ALGORITHM

Algorithm: Multi-factor scoring system

Factors Considered:
1. Report Type (0-30 points)
   - Water Leak: 30 points (high priority - can cause damage)
   - Pothole: 25 points (safety hazard)
   - Street Light: 20 points (security concern)
   - Garbage: 15 points (health concern)
   - Other: 10 points

2. Location Density (0-25 points)
   - Counts nearby reports within 500m radius
   - More reports = higher priority
   - Formula: min(nearbyReports * 2, 25)

3. User Engagement (0-20 points)
   - Likes: 2 points each
   - Comments: 3 points each
   - Formula: min((likes * 2) + (comments * 3), 20)

4. Time Decay (0-15 points)
   - Older reports get higher priority
   - Formula: min(daysSinceCreation * 2, 15)

5. Urgency Keywords (0-10 points)
   - Scans description for urgent keywords
   - Keywords: urgent, emergency, dangerous, critical, immediate, severe, broken, damaged
   - 2 points per keyword found, capped at 10

Final Score: Sum of all factors, normalized to 0-100

Implementation:
- Function: calculatePriorityScore(report, historicalData)
- Called automatically when report is submitted
- Stored in report.priority_score field

4.2 DUPLICATE DETECTION

Algorithm: Location-based + Text Similarity

Process:
1. Find reports within 100 meters of new report location
2. Calculate text similarity using Jaro-Winkler distance
3. Compare titles and descriptions
4. Check if same report type
5. If similarity > 0.7 and same type → mark as duplicate

Jaro-Winkler Distance:
- Measures similarity between two strings
- Returns value between 0 (completely different) and 1 (identical)
- Threshold: 0.7 (70% similarity)

Implementation:
- Function: detectDuplicates(newReport)
- Returns array of potential duplicates with similarity scores
- Sets is_duplicate flag and duplicate_of reference

4.3 SENTIMENT ANALYSIS

Algorithm: Lexicon-based sentiment analysis

Process:
1. Tokenize text into words
2. Count positive and negative words
3. Calculate sentiment score: (positive - negative) / total
4. Classify:
   - score > 0.2 → positive
   - score < -0.2 → negative
   - else → neutral

Positive Words:
good, great, excellent, fixed, resolved, thanks, thank, appreciate, helpful, fast, quick

Negative Words:
bad, terrible, awful, broken, damaged, urgent, dangerous, critical, failed, slow, delayed

Implementation:
- Function: analyzeSentiment(text)
- Returns: { sentiment, score, positiveCount, negativeCount }
- Applied to report descriptions and comments

4.4 AUTO-TAGGING

Algorithm: Keyword-based tag generation

Process:
1. Analyze report title, description, and address
2. Match against predefined patterns
3. Generate relevant tags

Tag Categories:
- Location-based: street, park, school, hospital
- Urgency: urgent, safety-hazard
- Content: water-related, traffic, health
- Type: report_type converted to tag

Implementation:
- Function: generateTags(report)
- Returns array of unique tags
- Stored in report.ai_tags field

4.5 IMAGE CLASSIFICATION

Algorithm: Text-based classification (placeholder for ML model)

Current Implementation:
- Analyzes text description and title
- Matches keywords to report types
- Calculates confidence based on keyword matches

Report Type Keywords:
- Pothole: pothole, hole, road, crack, damage
- Garbage: garbage, trash, waste, litter, dump
- Street Light: light, lamp, dark, illumination, bulb
- Water Leak: water, leak, pipe, flood, drainage

Future Enhancement:
- Integrate TensorFlow.js for actual image classification
- Use pre-trained models (MobileNet, ResNet)
- Process images client-side or server-side

Implementation:
- Function: classifyImageFromReport(report)
- Returns: { predictedType, confidence }
- Stored in report.ai_classification field

4.6 PREDICTIVE ANALYTICS

Algorithm: Location clustering and risk scoring

Process:
1. Get all active reports (PENDING, WORKING)
2. Cluster reports by location (round to 0.01 degrees ≈ 1km)
3. Calculate risk score for each cluster:
   - Base score: cluster count * 10
   - Diversity bonus: unique report types * 5
4. Return top 10 high-risk areas

Risk Score Formula:
riskScore = (reportCount * 10) + (uniqueTypes * 5)

Implementation:
- Function: predictHighRiskAreas(radius)
- Returns array of risk areas with location and metadata
- Used in admin dashboard for proactive planning

================================================================================
5. API ENDPOINTS
================================================================================

5.1 POST /api/reports
   - Automatically applies all AI features when report is submitted
   - Returns report with AI-generated fields populated

5.2 GET /api/reports/ai/insights
   - Access: Admin only
   - Returns:
     * High-risk areas
     * High-priority reports
     * Sentiment analysis summary
     * Duplicate report count
     * AI features status

5.3 GET /api/reports/ai/priority
   - Access: Authenticated users
   - Returns reports sorted by priority_score (descending)
   - Limit: 50 reports

================================================================================
6. FRONTEND INTEGRATION
================================================================================

6.1 Admin Dashboard
   - New "AI Insights" section
   - Displays:
     * High-priority reports sorted by AI score
     * Risk areas map
     * Sentiment analysis charts
     * AI features status

6.2 Worker Dashboard
   - Priority score column in reports table
   - Color-coded badges:
     * Red (70+): High priority
     * Yellow (50-69): Medium priority
     * Blue (<50): Low priority

6.3 Report Display
   - Shows AI tags as badges
   - Displays sentiment indicators
   - Highlights duplicate reports

Components:
- client/src/components/dashboards/AIInsights.js
- Updated: AdminDashboard.js, WorkerDashboard.js

================================================================================
7. HOW IT'S DONE - STEP BY STEP
================================================================================

7.1 WHEN A REPORT IS SUBMITTED:

Step 1: User submits report with image, title, description, location
Step 2: Backend receives POST /api/reports
Step 3: Image uploaded to Cloudinary
Step 4: AI Processing Pipeline:
   a. Calculate priority score
   b. Generate AI tags
   c. Analyze sentiment
   d. Classify image/type
   e. Detect duplicates
Step 5: Store report with all AI fields
Step 6: Return enriched report to frontend

7.2 WHEN ADMIN VIEWS INSIGHTS:

Step 1: Admin clicks "Show AI Insights"
Step 2: Frontend calls GET /api/reports/ai/insights
Step 3: Backend:
   a. Finds high-risk areas
   b. Gets top priority reports
   c. Analyzes all comments for sentiment
   d. Counts duplicates
Step 4: Returns aggregated insights
Step 5: Frontend displays in AIInsights component

7.3 DUPLICATE DETECTION FLOW:

Step 1: New report submitted
Step 2: Query reports within 100m radius
Step 3: For each nearby report:
   a. Calculate title similarity (Jaro-Winkler)
   b. Calculate description similarity
   c. Check if same type
Step 4: If similarity > 0.7 and same type:
   a. Mark new report as duplicate
   b. Link to original report
Step 5: Store duplicate flag

7.4 PRIORITY SCORING FLOW:

Step 1: Extract report features
Step 2: Calculate type score (0-30)
Step 3: Count nearby reports (0-25)
Step 4: Count engagement (0-20)
Step 5: Calculate time decay (0-15)
Step 6: Scan for urgency keywords (0-10)
Step 7: Sum all factors
Step 8: Normalize to 0-100
Step 9: Store in priority_score field

================================================================================
8. DATA FLOW DIAGRAM
================================================================================

User Submission
    ↓
Report Form (Frontend)
    ↓
POST /api/reports
    ↓
Upload Image → Cloudinary
    ↓
AI Service Processing:
    ├─→ Priority Scoring
    ├─→ Duplicate Detection
    ├─→ Sentiment Analysis
    ├─→ Auto-Tagging
    └─→ Image Classification
    ↓
Save to Database (with AI fields)
    ↓
Return Enriched Report
    ↓
Display in Dashboard

================================================================================
9. ALGORITHM COMPLEXITY
================================================================================

Priority Scoring: O(1) - Constant time
Duplicate Detection: O(n) - Linear (n = nearby reports)
Sentiment Analysis: O(m) - Linear (m = text length)
Auto-Tagging: O(1) - Constant time
Image Classification: O(1) - Constant time (current implementation)
Predictive Analytics: O(n) - Linear (n = total reports)

Overall: Efficient for real-time processing

================================================================================
10. FUTURE ENHANCEMENTS
================================================================================

10.1 ADVANCED IMAGE CLASSIFICATION
   - Integrate TensorFlow.js
   - Use pre-trained CNN models (MobileNet, ResNet)
   - Real-time image analysis
   - Confidence scores for classifications

10.2 MACHINE LEARNING MODELS
   - Train custom models on historical data
   - Predict resolution time
   - Predict required budget
   - Predict optimal workforce allocation

10.3 NATURAL LANGUAGE PROCESSING
   - Named Entity Recognition (extract locations, dates)
   - Topic modeling (identify common themes)
   - Automatic report summarization
   - Multi-language support

10.4 RECOMMENDATION SYSTEM
   - Suggest similar resolved reports
   - Recommend solutions based on history
   - Suggest optimal worker assignment

10.5 TIME SERIES ANALYSIS
   - Predict seasonal patterns
   - Forecast future report volumes
   - Identify trends over time

10.6 COMPUTER VISION
   - Damage severity assessment from images
   - Automatic measurement estimation
   - Quality assessment of repairs

================================================================================
11. TESTING & VALIDATION
================================================================================

11.1 PRIORITY SCORING
   - Test with various report types
   - Verify scores are in 0-100 range
   - Check that urgent reports get high scores

11.2 DUPLICATE DETECTION
   - Test with identical reports
   - Test with similar but different reports
   - Verify similarity threshold (0.7)

11.3 SENTIMENT ANALYSIS
   - Test with positive, negative, neutral text
   - Verify keyword detection
   - Check score calculations

11.4 PREDICTIVE ANALYTICS
   - Verify clustering algorithm
   - Check risk score calculations
   - Validate location grouping

================================================================================
12. PERFORMANCE CONSIDERATIONS
================================================================================

12.1 OPTIMIZATION
   - Caching of AI results
   - Batch processing for large datasets
   - Indexed database queries
   - Async processing for heavy operations

12.2 SCALABILITY
   - Current implementation handles real-time processing
   - For large scale: consider background jobs
   - Use message queues for async processing
   - Consider ML model serving infrastructure

================================================================================
13. SECURITY & PRIVACY
================================================================================

13.1 DATA PRIVACY
   - AI processing uses only report data
   - No personal information in ML models
   - Sentiment analysis is text-only

13.2 ACCESS CONTROL
   - AI insights: Admin only
   - Priority scores: Visible to workers
   - Duplicate flags: Internal use

================================================================================
14. MAINTENANCE & UPDATES
================================================================================

14.1 MODEL UPDATES
   - Priority scoring weights can be adjusted
   - Sentiment keywords can be expanded
   - Classification rules can be refined

14.2 MONITORING
   - Track AI accuracy
   - Monitor processing time
   - Log errors and edge cases

================================================================================
15. CONCLUSION
================================================================================

The AI and ML features in Janaspandana provide intelligent automation and
insights that help improve civic issue management. The implementation uses
proven algorithms and can be extended with more advanced ML models as needed.

All features are production-ready and integrated seamlessly into the existing
application architecture.

================================================================================
16. WORKFORCE & BUDGET PREDICTION ML MODEL
================================================================================

16.1 OVERVIEW
   - Machine Learning model that learns from historical data
   - Predicts optimal workforce and budget for new reports
   - Improves accuracy over time as more data is collected
   - Available in Worker Dashboard for assistance

16.2 HOW IT WORKS

Training Process:
1. Collects all cleared reports with assigned workforce and budget
2. Analyzes patterns by report type
3. Calculates correlations between priority scores and resources
4. Builds predictive model with weighted factors
5. Updates model weights based on historical averages

Prediction Factors:
1. Report Type: Base workforce/budget from historical averages
2. Priority Score: Higher priority = more resources needed
3. Area Density: More nearby reports = more resources
4. Complexity Multipliers: Type-specific complexity factors

16.3 MODEL ARCHITECTURE

Workforce Prediction:
- Base: 2 workers
- Type-based average from training data
- Priority multiplier: (priority/100) * 0.5 * 3
- Area density: min(nearbyReports * 0.5, 5)
- Complexity multipliers by type
- Range: 1-20 workers

Budget Prediction:
- Base: ₹5,000
- Type-based average from training data
- Priority multiplier: (priority/100) * 0.8 * 10,000
- Area density: min(nearbyReports * 2000, 50000)
- Complexity multipliers by type
- Range: ₹1,000 - ₹500,000

16.4 TRAINING REQUIREMENTS

Minimum Data:
- At least 10 cleared reports
- Reports must have assigned_workforce > 0
- Reports must have assigned_budget > 0

Training Frequency:
- Can be triggered manually by Admin/Supervisor
- Should be retrained periodically as data grows
- Model improves with more training samples

16.5 USAGE IN WORKER DASHBOARD

Features:
- "Get AI Suggestions" button in assignment modal
- Shows predicted workforce and budget
- Displays confidence level
- "Use AI Suggestions" button to auto-fill
- Shows reasoning factors

Confidence Levels:
- 0-50%: Model not trained or insufficient data
- 50-75%: Model trained but limited data
- 75-95%: Model well-trained with good data

16.6 API ENDPOINTS

GET /api/reports/:id/ai-suggestions
- Returns predictions for a specific report
- Access: Workers only
- Returns: predictedWorkforce, predictedBudget, confidence, reasoning

POST /api/reports/ai/train-model
- Trains the ML model on historical data
- Access: Admin/Supervisor only
- Returns: training status, sample count, success message

GET /api/reports/ai/model-stats
- Returns current model statistics
- Access: Authenticated users
- Returns: trained status, confidence, report types, weights

16.7 CONTINUOUS LEARNING

The model learns from:
- Historical assignments that led to successful resolutions
- Patterns in resource allocation by report type
- Correlation between priority and required resources
- Area-specific resource needs

As more reports are cleared with workforce and budget data:
- Model accuracy improves
- Predictions become more reliable
- Confidence scores increase
- Better resource allocation recommendations

================================================================================
END OF DOCUMENTATION
================================================================================

